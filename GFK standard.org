# Copyright (C) 2022 Jeremiah Orians
# This file is part of GFK
#
# GFK is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GFK is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GFK If not, see <http://www.gnu.org/licenses/>.

* inode
inode structs are made up of 1 mandatory chunk and all optional chunks as enabled in the superblock.

| chunk | size               | purpose          | optional? |
|-------+--------------------+------------------+-----------|
|     0 | leadblock defined  | block address    | no        |
|     1 | superblock defined | checksum         | yes       |

* dnode
dnodes structs are made up of 2 mandatory inode structs, 1 mandatory chunk and all optional chucks as enabled in the superblock.

| chunk | size              | purpose               | optional? |
|-------+-------------------+-----------------------+-----------|
|     0 | size of inode     | pointer to name       | no        |
|     1 | size of inode     | pointer to contents   | no        |
|     2 | leadblock defined | size of file in bytes | no        |
|     3 | size of inode     | pointer to metadata   | yes       |

chunk 2 is to be interpreted to mean:
if pointing to a file/Indirect File: the size of that file in bytes
if anything else: ZERO to simplify bootstrapping implementations.

* Blocks
The filesystem is made up of blocks of a size defined in the leadblock.

The first byte of every block structure is its type.
(except for the leadblock and the superblock)

| Value | Type               | optional support? |
|-------+--------------------+-------------------|
|     0 | Direct File        | no                |
|     1 | Indirect File      | no                |
|     2 | Directory          | no                |
|     3 | Indirect Directory | no                |
|     4 | Metadata           | yes               |
|     5 | Indirect Metadata  | yes               |
|     6 | reserved           | yes               |
|     7 | Indirect reserved  | yes               |

** Leadblock
To compenstate for hardware that doesn't make knowing the size of the drive simple.

the 2rd native logical block is the leadblock.

For example if the hardware default block size is 256bytes: the Leadblock would be
found exactly after 256bytes from the start of the disk (regardless what the block
size is for the GFK filesystem according to the leadblock)

The Leadblock size is to be the larger of the following:
64Bytes in size
or
the size of the native logical block size of the storage medium it is upon

(if native logical block size is 1byte; use 64bytes)
(if native logical block size is 1MB; use 1MB)

All reserved bytes are to be zero.

| chunk | size   | purpose                     | optional? | Default value            |
|-------+--------+-----------------------------+-----------+--------------------------|
|     0 | 64bits | encoding flags              | no        | 0/1 (see note)           |
|     1 | 64bits | size of blocks              | no        | 4096                     |
|     2 | 64bits | size of block pointer       | no        | architecture word size   |
|     3 | 64bits | size of file size           | no        | 4                        |
|     4 | 64bits | block address of SuperBlock | no        | last block (see section) |
|     5 | 64bits | Native block size           | no        | (see note)               |
|     6 | rest   | reserved chunk              | yes       | 0                        |

*** encoding flags
the bits of the encoding flags chunk must be interpreted in big bit endian fashion.
note middle or other endianess are not supported
(and will never be supported)

All following data is to be interpreted according to the encoding order encoded here.

bits 2-63 are to be used as an integer indicating the Leadblock format version number.
This version of the specification is Leadblock formation version 0 and no newer formats
currently exist.

|  bit | purpose                  | value 0         | value 1            |
|------+--------------------------+-----------------+--------------------|
|    0 | word endianess           | Big byte endian | Little byte endian |
|    1 | bit endianess            | Big bit endian  | Little bit endian  |

*** block size
blocks must be atleast 64bytes in size or the size of 4 dnodes; whichever is larger.
block size is expressed as a number of bytes.

The Default block size is 4096Bytes

*** Native block size
This is the native block size for the device the filesystem is on.
Common values are 512bytes and 4096 bytes

If the native block size is larger than the block size and the packed feature is
not enabled, then the block will only contain a single block wasting space.

If the native block size is smaller than the block size; then as many blocks in
a row are leveraged. If the block size is not a multiple of the native block size
then excess native blocks will be allocated and the space will be wasted.

*** size of block pointer
block pointers must be a multiple of bytes.
block pointer size is expressed as a number of bytes.
Common values are 2, 4 and 8 corresponding to 16bit, 32bit and 64bit pointers.
However the value can be up to (2^64)-1

*** size of file size
the size of the file size dnode segment must be a multiple of bytes.
size of the file size is expressed as a number of bytes.
Common values are 2, 4 and 8 corresponding to 16bit, 32bit and 64bit file size dnode
segment sizes.
However the value can be up to (2^64) -1

** Superblock
The superblock can be located anywhere on the disk *AFTER* the leadblock.
HOWEVER if the Superblock is being made manually it is to be located at the last
logical block of the filesystem.

if The Superblock isn't located in the last logical block of the filesystem then,
the last logical block of the filesystem will be reserved in the event that a user
needs to manually replace the Superblock or for tools to build a replacement
Superblock without fear of overwriting any data.

Each piece is 64bits long (8bytes)
| Piece | Contents           | optional? |            Default value |
|-------+--------------------+-----------+--------------------------|
|     0 | SuperBlock HEADER  | no        |       0x4B4E49474854210A |
|     1 | Core Feature Flags | no        | if zero all features OFF |
|     2 | checksum algorithm | yes       |                        0 |
|     3 | checksum size      | yes       |                        0 |
|     4 | ROOT pair          | no        |                      N/A |
|   5-? | optional checksum  | yes       |                        0 |

as one can not expect the block size to be larger than 64bytes,
the rest of the block is to be zero if it is greater than 64bytes.

The Superblock header is to *ALWAYS* be written in Big Endian order such that if
viewed in a text editor it would appear as: KNIGHT!\n to the reader.

*** Feature flags
|  bit | feature                  | support required? |
|------+--------------------------+-------------------|
|    0 | filesystem checksuming   | no                |
|    1 | filesystem deduplication | no                |
| 2-63 | reserved for future use  | no                |

*** checksum algorithm
If checksumming support is enabled:
all inodes must include a checksum field containing the checksum of the block being addressed.

| value | name         | support required? |
|-------+--------------+-------------------|
|     0 | NULL         | yes               |
|     1 | BSD checksum | yes               |
|     2 | MD5          | no                |
|     3 | SHA-1        | no                |
|     4 | SHA-2        | no                |

**** NULL
The null algorithm is to populate the field with just the value zero.
Tools *SHOULD NOT* create filesystems with this standard but must support reading
filesystems that do use it.

**** BSD checksum
The checksum is to be defined as:

checksum checksumblock(char* block, int volume_block_size, int mask)
{
	int checksum = 0;
	int i = 0;
	int ch;

	while (i < volume_block_size)
	{
		ch = block[i];
		checksum = (checksum >> 1) + ((checksum & 1) << 15);
		checksum += ch;
		checksum &= mask;
		i += 1;
	}
	return checksum;
}

where a 16bit version would have a mask of 0xFFFF
a 32bit version would have a mask of 0xFFFFFFFF
a 64bit version wold have a mask of 0xFFFFFFFFFFFFFFFF

*** checksum size
checksum size is expressed as a number of bits.

| checksum     | size | support required? |
|--------------+------+-------------------|
| NULL         |  ANY | yes               |
| BSD Checksum |   16 | yes               |
| BSD Checksum |   32 | yes               |
| BSD Checksum |   64 | no                |
| MD5          |  128 | no                |
| SHA-1        |  160 | no                |
| SHA-2        |  224 | no                |
| SHA-2        |  256 | no                |
| SHA-2        |  384 | no                |
| SHA-2        |  512 | no                |

all other checksum algorithm and size combos
are not considered valid.

** Directory blocks
| bytes | Contents | Default Value |
|-------+----------+---------------|
| 1     | Type tag | 0b00000010    |
| rest  | dnodes   | 0             |

the dnodes are the files and folders within the directory.

** file block
| bytes | Contents | Default Value |
|-------+----------+---------------|
| 1     | Type tag | 0b00000100    |
| rest  | inodes   | 0             |

the inodes are the contents of the file itself

** Indirect Directory blocks
| bytes | Contents | Default Value |
|-------+----------+---------------|
| 1     | Type tag | 0b00000011    |
| rest  | inodes   | 0             |

the inodes are the indirect directory and directory blocks needed to contain the contents of the folder.

** Indirect file block
| bytes | Contents | Default Value |
|-------+----------+---------------|
| 1     | Type tag | 0b00000101    |
| rest  | inodes   | 0             |

the indoes are the indirect file and file blocks needed to contain the contents of the file.

** name blocks
file names are null terminated and limited to the block size -1
file names can not contain null characters or forward slashes (/)
